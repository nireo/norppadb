package db

import (
	"io"
	"time"

	"github.com/dgraph-io/badger/v3"
)

// BadgerBackend also want to support in memory databases for quick access to improve
// the store implementation's performance. Sometimes the raft store wants to
// just spin up a fast instance and not having to parse/write to source files
// improves performance.
type BadgerBackend struct {
	DB           *badger.DB
	LastSnapshot time.Time
	IsMem        bool
}

type KVPair struct {
	Key   []byte
	Value []byte
}

// NewBadgerBackend creates/opens a badger database on disk. Slower than opening one
// in memory, but the storage is persistant. The default option.
func NewBadgerBackend(path string) (*BadgerBackend, error) {
	opts := badger.DefaultOptions(path)
	opts.Logger = nil

	db, err := badger.Open(opts)
	if err != nil {
		return nil, err
	}

	return &BadgerBackend{
		DB:           db,
		LastSnapshot: time.Now(),
		IsMem:        false,
	}, nil
}

// NewBadgerBackendMemory creates a badger database in memory. This is used when we
// want to start-up a badger connection fast and write temporary values into it.
// mostly used when recovering a Raft cluster.
func NewBadgerBackendMemory() (*BadgerBackend, error) {
	db, err := badger.Open(badger.DefaultOptions("").WithInMemory(true))
	if err != nil {
		return nil, err
	}

	return &BadgerBackend{
		DB:           db,
		LastSnapshot: time.Now(),
		IsMem:        true,
	}, nil
}

// Close closes the database connection.
func (b *BadgerBackend) Close() error {
	return b.DB.Close()
}

// Put writes a given key value pair into the database, prefer using the db.BatchWrite
// when writing multiple keys, since this creates separate transactions for each write.
func (b *BadgerBackend) Put(key, value []byte) error {
	return b.DB.Update(func(txn *badger.Txn) error {
		return txn.Set(key, value)
	})
}

// Get gets a key from the collection. It is quite slow as it copies the bytes from
// the database and creates a transaction but we don't really have a better choice.
func (b *BadgerBackend) Get(key []byte) ([]byte, error) {
	var val []byte
	err := b.DB.View(func(txn *badger.Txn) error {
		item, err := txn.Get(key)
		if err != nil {
			return err
		}
		err = item.Value(func(valp []byte) error {
			val = append([]byte{}, valp...)
			return nil
		})
		return err
	})
	return val, err
}

// Delete deletes a given key from the collection. Avoid using single operations, since
// they create a separate transaction for each action. Meaning that they generate a
// noticable amount of overhead.
func (b *BadgerBackend) Delete(key []byte) error {
	return b.DB.Update(func(txn *badger.Txn) error {
		return txn.Delete(key)
	})
}

// Backup writes the database state into a given io.Writer. This is used to take Raft
// snapshots. The db.Load() function loads the database that this function has written.
func (b *BadgerBackend) Backup(w io.Writer) error {
	_, err := b.DB.Backup(w, uint64(b.LastSnapshot.Unix()))
	if err != nil {
		return err
	}
	b.LastSnapshot = time.Now()
	return err
}

// Load loads a snapshot of the database from a given reader. This is used when loading
// a database's state from a Raft snapshot. The data that Load reads is generated by the
// db.Backup() function.
func (b *BadgerBackend) Load(r io.Reader) error {
	return b.DB.Load(r, 4)
}

// BatchWrite writes a list of pairs into the collection. It is faster to write many
// entries using this since this doesn't create a separate write transaction for each
// pair.
func (b *BadgerBackend) BatchWrite(pairs []*KVPair) error {
	batch := b.DB.NewWriteBatch()
	defer batch.Cancel()

	for i := range pairs {
		entry := badger.NewEntry(pairs[i].Key, pairs[i].Value)
		if err := batch.SetEntry(entry); err != nil {
			return err
		}
	}

	return batch.Flush()
}

// BatchGet tries to find all of the keys listed in the keys parameter. If a key is not
// found, it will be ignored and the function will continue on to the next one.
func (b *BadgerBackend) BatchGet(keys [][]byte) ([]*KVPair, error) {
	// cannot really preallocate these since we wont know how many of them will
	// exist
	res := make([]*KVPair, 0)

	for i := range keys {
		val, err := b.Get(keys[i])
		if err != nil || val == nil {
			continue
		}

		res = append(res, &KVPair{
			Key:   keys[i],
			Value: val,
		})
	}
	return res, nil
}

// PrefixScan finds all the keys in the database that starts with the given
// prefix.
func (b *BadgerBackend) PrefixScan(prefix []byte) ([]*KVPair, error) {
	res := make([]*KVPair, 0)

	err := b.DB.View(func(txn *badger.Txn) error {
		it := txn.NewIterator(badger.DefaultIteratorOptions)
		defer it.Close()
		for it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() {
			item := it.Item()

			v, err := item.ValueCopy(nil)
			if err != nil {
				return err
			}

			res = append(res, &KVPair{
				Key:   item.KeyCopy(nil),
				Value: v,
			})
		}
		return nil
	})

	return res, err
}

// GarbageCollector runs the Badger garbage collector every five minutes.
func (b *BadgerBackend) GarbageCollector() {
	ticker := time.NewTicker(5 * time.Minute)
	defer ticker.Stop()
	for range ticker.C {
	again:
		if err := b.DB.RunValueLogGC(0.7); err == nil {
			goto again
		}
	}
}
